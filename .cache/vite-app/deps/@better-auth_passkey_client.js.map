{
  "version": 3,
  "sources": ["../../../node_modules/.pnpm/@simplewebauthn+browser@13.2.2/node_modules/@simplewebauthn/browser/esm/helpers/bufferToBase64URLString.js", "../../../node_modules/.pnpm/@simplewebauthn+browser@13.2.2/node_modules/@simplewebauthn/browser/esm/helpers/base64URLStringToBuffer.js", "../../../node_modules/.pnpm/@simplewebauthn+browser@13.2.2/node_modules/@simplewebauthn/browser/esm/helpers/browserSupportsWebAuthn.js", "../../../node_modules/.pnpm/@simplewebauthn+browser@13.2.2/node_modules/@simplewebauthn/browser/esm/helpers/toPublicKeyCredentialDescriptor.js", "../../../node_modules/.pnpm/@simplewebauthn+browser@13.2.2/node_modules/@simplewebauthn/browser/esm/helpers/isValidDomain.js", "../../../node_modules/.pnpm/@simplewebauthn+browser@13.2.2/node_modules/@simplewebauthn/browser/esm/helpers/webAuthnError.js", "../../../node_modules/.pnpm/@simplewebauthn+browser@13.2.2/node_modules/@simplewebauthn/browser/esm/helpers/identifyRegistrationError.js", "../../../node_modules/.pnpm/@simplewebauthn+browser@13.2.2/node_modules/@simplewebauthn/browser/esm/helpers/webAuthnAbortService.js", "../../../node_modules/.pnpm/@simplewebauthn+browser@13.2.2/node_modules/@simplewebauthn/browser/esm/helpers/toAuthenticatorAttachment.js", "../../../node_modules/.pnpm/@simplewebauthn+browser@13.2.2/node_modules/@simplewebauthn/browser/esm/methods/startRegistration.js", "../../../node_modules/.pnpm/@simplewebauthn+browser@13.2.2/node_modules/@simplewebauthn/browser/esm/helpers/browserSupportsWebAuthnAutofill.js", "../../../node_modules/.pnpm/@simplewebauthn+browser@13.2.2/node_modules/@simplewebauthn/browser/esm/helpers/identifyAuthenticationError.js", "../../../node_modules/.pnpm/@simplewebauthn+browser@13.2.2/node_modules/@simplewebauthn/browser/esm/methods/startAuthentication.js", "../../../node_modules/.pnpm/@better-auth+passkey@1.4.18_@better-auth+core@1.4.18_@better-auth+utils@0.3.0_@better-f_1e9da6290195222e57b9b41913ab5746/node_modules/@better-auth/passkey/src/client.ts"],
  "sourcesContent": ["/**\n * Convert the given array buffer into a Base64URL-encoded string. Ideal for converting various\n * credential response ArrayBuffers to string for sending back to the server as JSON.\n *\n * Helper method to compliment `base64URLStringToBuffer`\n */\nexport function bufferToBase64URLString(buffer) {\n    const bytes = new Uint8Array(buffer);\n    let str = '';\n    for (const charCode of bytes) {\n        str += String.fromCharCode(charCode);\n    }\n    const base64String = btoa(str);\n    return base64String.replace(/\\+/g, '-').replace(/\\//g, '_').replace(/=/g, '');\n}\n", "/**\n * Convert from a Base64URL-encoded string to an Array Buffer. Best used when converting a\n * credential ID from a JSON string to an ArrayBuffer, like in allowCredentials or\n * excludeCredentials\n *\n * Helper method to compliment `bufferToBase64URLString`\n */\nexport function base64URLStringToBuffer(base64URLString) {\n    // Convert from Base64URL to Base64\n    const base64 = base64URLString.replace(/-/g, '+').replace(/_/g, '/');\n    /**\n     * Pad with '=' until it's a multiple of four\n     * (4 - (85 % 4 = 1) = 3) % 4 = 3 padding\n     * (4 - (86 % 4 = 2) = 2) % 4 = 2 padding\n     * (4 - (87 % 4 = 3) = 1) % 4 = 1 padding\n     * (4 - (88 % 4 = 0) = 4) % 4 = 0 padding\n     */\n    const padLength = (4 - (base64.length % 4)) % 4;\n    const padded = base64.padEnd(base64.length + padLength, '=');\n    // Convert to a binary string\n    const binary = atob(padded);\n    // Convert binary string to buffer\n    const buffer = new ArrayBuffer(binary.length);\n    const bytes = new Uint8Array(buffer);\n    for (let i = 0; i < binary.length; i++) {\n        bytes[i] = binary.charCodeAt(i);\n    }\n    return buffer;\n}\n", "/**\n * Determine if the browser is capable of Webauthn\n */\nexport function browserSupportsWebAuthn() {\n    return _browserSupportsWebAuthnInternals.stubThis(globalThis?.PublicKeyCredential !== undefined &&\n        typeof globalThis.PublicKeyCredential === 'function');\n}\n/**\n * Make it possible to stub the return value during testing\n * @ignore Don't include this in docs output\n */\nexport const _browserSupportsWebAuthnInternals = {\n    stubThis: (value) => value,\n};\n", "import { base64URLStringToBuffer } from './base64URLStringToBuffer.js';\nexport function toPublicKeyCredentialDescriptor(descriptor) {\n    const { id } = descriptor;\n    return {\n        ...descriptor,\n        id: base64URLStringToBuffer(id),\n        /**\n         * `descriptor.transports` is an array of our `AuthenticatorTransportFuture` that includes newer\n         * transports that TypeScript's DOM lib is ignorant of. Convince TS that our list of transports\n         * are fine to pass to WebAuthn since browsers will recognize the new value.\n         */\n        transports: descriptor.transports,\n    };\n}\n", "/**\n * A simple test to determine if a hostname is a properly-formatted domain name\n *\n * A \"valid domain\" is defined here: https://url.spec.whatwg.org/#valid-domain\n *\n * Regex sourced from here:\n * https://www.oreilly.com/library/view/regular-expressions-cookbook/9781449327453/ch08s15.html\n */\nexport function isValidDomain(hostname) {\n    return (\n    // Consider localhost valid as well since it's okay wrt Secure Contexts\n    hostname === 'localhost' ||\n        /^([a-z0-9]+(-[a-z0-9]+)*\\.)+[a-z]{2,}$/i.test(hostname));\n}\n", "/**\n * A custom Error used to return a more nuanced error detailing _why_ one of the eight documented\n * errors in the spec was raised after calling `navigator.credentials.create()` or\n * `navigator.credentials.get()`:\n *\n * - `AbortError`\n * - `ConstraintError`\n * - `InvalidStateError`\n * - `NotAllowedError`\n * - `NotSupportedError`\n * - `SecurityError`\n * - `TypeError`\n * - `UnknownError`\n *\n * Error messages were determined through investigation of the spec to determine under which\n * scenarios a given error would be raised.\n */\nexport class WebAuthnError extends Error {\n    constructor({ message, code, cause, name, }) {\n        // @ts-ignore: help Rollup understand that `cause` is okay to set\n        super(message, { cause });\n        Object.defineProperty(this, \"code\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.name = name ?? cause.name;\n        this.code = code;\n    }\n}\n", "import { isValidDomain } from './isValidDomain.js';\nimport { WebAuthnError } from './webAuthnError.js';\n/**\n * Attempt to intuit _why_ an error was raised after calling `navigator.credentials.create()`\n */\nexport function identifyRegistrationError({ error, options, }) {\n    const { publicKey } = options;\n    if (!publicKey) {\n        throw Error('options was missing required publicKey property');\n    }\n    if (error.name === 'AbortError') {\n        if (options.signal instanceof AbortSignal) {\n            // https://www.w3.org/TR/webauthn-2/#sctn-createCredential (Step 16)\n            return new WebAuthnError({\n                message: 'Registration ceremony was sent an abort signal',\n                code: 'ERROR_CEREMONY_ABORTED',\n                cause: error,\n            });\n        }\n    }\n    else if (error.name === 'ConstraintError') {\n        if (publicKey.authenticatorSelection?.requireResidentKey === true) {\n            // https://www.w3.org/TR/webauthn-2/#sctn-op-make-cred (Step 4)\n            return new WebAuthnError({\n                message: 'Discoverable credentials were required but no available authenticator supported it',\n                code: 'ERROR_AUTHENTICATOR_MISSING_DISCOVERABLE_CREDENTIAL_SUPPORT',\n                cause: error,\n            });\n        }\n        else if (\n        // @ts-ignore: `mediation` doesn't yet exist on CredentialCreationOptions but it's possible as of Sept 2024\n        options.mediation === 'conditional' &&\n            publicKey.authenticatorSelection?.userVerification === 'required') {\n            // https://w3c.github.io/webauthn/#sctn-createCredential (Step 22.4)\n            return new WebAuthnError({\n                message: 'User verification was required during automatic registration but it could not be performed',\n                code: 'ERROR_AUTO_REGISTER_USER_VERIFICATION_FAILURE',\n                cause: error,\n            });\n        }\n        else if (publicKey.authenticatorSelection?.userVerification === 'required') {\n            // https://www.w3.org/TR/webauthn-2/#sctn-op-make-cred (Step 5)\n            return new WebAuthnError({\n                message: 'User verification was required but no available authenticator supported it',\n                code: 'ERROR_AUTHENTICATOR_MISSING_USER_VERIFICATION_SUPPORT',\n                cause: error,\n            });\n        }\n    }\n    else if (error.name === 'InvalidStateError') {\n        // https://www.w3.org/TR/webauthn-2/#sctn-createCredential (Step 20)\n        // https://www.w3.org/TR/webauthn-2/#sctn-op-make-cred (Step 3)\n        return new WebAuthnError({\n            message: 'The authenticator was previously registered',\n            code: 'ERROR_AUTHENTICATOR_PREVIOUSLY_REGISTERED',\n            cause: error,\n        });\n    }\n    else if (error.name === 'NotAllowedError') {\n        /**\n         * Pass the error directly through. Platforms are overloading this error beyond what the spec\n         * defines and we don't want to overwrite potentially useful error messages.\n         */\n        return new WebAuthnError({\n            message: error.message,\n            code: 'ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY',\n            cause: error,\n        });\n    }\n    else if (error.name === 'NotSupportedError') {\n        const validPubKeyCredParams = publicKey.pubKeyCredParams.filter((param) => param.type === 'public-key');\n        if (validPubKeyCredParams.length === 0) {\n            // https://www.w3.org/TR/webauthn-2/#sctn-createCredential (Step 10)\n            return new WebAuthnError({\n                message: 'No entry in pubKeyCredParams was of type \"public-key\"',\n                code: 'ERROR_MALFORMED_PUBKEYCREDPARAMS',\n                cause: error,\n            });\n        }\n        // https://www.w3.org/TR/webauthn-2/#sctn-op-make-cred (Step 2)\n        return new WebAuthnError({\n            message: 'No available authenticator supported any of the specified pubKeyCredParams algorithms',\n            code: 'ERROR_AUTHENTICATOR_NO_SUPPORTED_PUBKEYCREDPARAMS_ALG',\n            cause: error,\n        });\n    }\n    else if (error.name === 'SecurityError') {\n        const effectiveDomain = globalThis.location.hostname;\n        if (!isValidDomain(effectiveDomain)) {\n            // https://www.w3.org/TR/webauthn-2/#sctn-createCredential (Step 7)\n            return new WebAuthnError({\n                message: `${globalThis.location.hostname} is an invalid domain`,\n                code: 'ERROR_INVALID_DOMAIN',\n                cause: error,\n            });\n        }\n        else if (publicKey.rp.id !== effectiveDomain) {\n            // https://www.w3.org/TR/webauthn-2/#sctn-createCredential (Step 8)\n            return new WebAuthnError({\n                message: `The RP ID \"${publicKey.rp.id}\" is invalid for this domain`,\n                code: 'ERROR_INVALID_RP_ID',\n                cause: error,\n            });\n        }\n    }\n    else if (error.name === 'TypeError') {\n        if (publicKey.user.id.byteLength < 1 || publicKey.user.id.byteLength > 64) {\n            // https://www.w3.org/TR/webauthn-2/#sctn-createCredential (Step 5)\n            return new WebAuthnError({\n                message: 'User ID was not between 1 and 64 characters',\n                code: 'ERROR_INVALID_USER_ID_LENGTH',\n                cause: error,\n            });\n        }\n    }\n    else if (error.name === 'UnknownError') {\n        // https://www.w3.org/TR/webauthn-2/#sctn-op-make-cred (Step 1)\n        // https://www.w3.org/TR/webauthn-2/#sctn-op-make-cred (Step 8)\n        return new WebAuthnError({\n            message: 'The authenticator was unable to process the specified options, or could not create a new credential',\n            code: 'ERROR_AUTHENTICATOR_GENERAL_ERROR',\n            cause: error,\n        });\n    }\n    return error;\n}\n", "class BaseWebAuthnAbortService {\n    constructor() {\n        Object.defineProperty(this, \"controller\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n    }\n    createNewAbortSignal() {\n        // Abort any existing calls to navigator.credentials.create() or navigator.credentials.get()\n        if (this.controller) {\n            const abortError = new Error('Cancelling existing WebAuthn API call for new one');\n            abortError.name = 'AbortError';\n            this.controller.abort(abortError);\n        }\n        const newController = new AbortController();\n        this.controller = newController;\n        return newController.signal;\n    }\n    cancelCeremony() {\n        if (this.controller) {\n            const abortError = new Error('Manually cancelling existing WebAuthn API call');\n            abortError.name = 'AbortError';\n            this.controller.abort(abortError);\n            this.controller = undefined;\n        }\n    }\n}\n/**\n * A service singleton to help ensure that only a single WebAuthn ceremony is active at a time.\n *\n * Users of **@simplewebauthn/browser** shouldn't typically need to use this, but it can help e.g.\n * developers building projects that use client-side routing to better control the behavior of\n * their UX in response to router navigation events.\n */\nexport const WebAuthnAbortService = new BaseWebAuthnAbortService();\n", "const attachments = ['cross-platform', 'platform'];\n/**\n * If possible coerce a `string` value into a known `AuthenticatorAttachment`\n */\nexport function toAuthenticatorAttachment(attachment) {\n    if (!attachment) {\n        return;\n    }\n    if (attachments.indexOf(attachment) < 0) {\n        return;\n    }\n    return attachment;\n}\n", "import { bufferToBase64URLString } from '../helpers/bufferToBase64URLString.js';\nimport { base64URLStringToBuffer } from '../helpers/base64URLStringToBuffer.js';\nimport { browserSupportsWebAuthn } from '../helpers/browserSupportsWebAuthn.js';\nimport { toPublicKeyCredentialDescriptor } from '../helpers/toPublicKeyCredentialDescriptor.js';\nimport { identifyRegistrationError } from '../helpers/identifyRegistrationError.js';\nimport { WebAuthnAbortService } from '../helpers/webAuthnAbortService.js';\nimport { toAuthenticatorAttachment } from '../helpers/toAuthenticatorAttachment.js';\n/**\n * Begin authenticator \"registration\" via WebAuthn attestation\n *\n * @param optionsJSON Output from **@simplewebauthn/server**'s `generateRegistrationOptions()`\n * @param useAutoRegister (Optional) Try to silently create a passkey with the password manager that the user just signed in with. Defaults to `false`.\n */\nexport async function startRegistration(options) {\n    // @ts-ignore: Intentionally check for old call structure to warn about improper API call\n    if (!options.optionsJSON && options.challenge) {\n        console.warn('startRegistration() was not called correctly. It will try to continue with the provided options, but this call should be refactored to use the expected call structure instead. See https://simplewebauthn.dev/docs/packages/browser#typeerror-cannot-read-properties-of-undefined-reading-challenge for more information.');\n        // @ts-ignore: Reassign the options, passed in as a positional argument, to the expected variable\n        options = { optionsJSON: options };\n    }\n    const { optionsJSON, useAutoRegister = false } = options;\n    if (!browserSupportsWebAuthn()) {\n        throw new Error('WebAuthn is not supported in this browser');\n    }\n    // We need to convert some values to Uint8Arrays before passing the credentials to the navigator\n    const publicKey = {\n        ...optionsJSON,\n        challenge: base64URLStringToBuffer(optionsJSON.challenge),\n        user: {\n            ...optionsJSON.user,\n            id: base64URLStringToBuffer(optionsJSON.user.id),\n        },\n        excludeCredentials: optionsJSON.excludeCredentials?.map(toPublicKeyCredentialDescriptor),\n    };\n    // Prepare options for `.create()`\n    const createOptions = {};\n    /**\n     * Try to use conditional create to register a passkey for the user with the password manager\n     * the user just used to authenticate with. The user won't be shown any prominent UI by the\n     * browser.\n     */\n    if (useAutoRegister) {\n        // @ts-ignore: `mediation` doesn't yet exist on CredentialCreationOptions but it's possible as of Sept 2024\n        createOptions.mediation = 'conditional';\n    }\n    // Finalize options\n    createOptions.publicKey = publicKey;\n    // Set up the ability to cancel this request if the user attempts another\n    createOptions.signal = WebAuthnAbortService.createNewAbortSignal();\n    // Wait for the user to complete attestation\n    let credential;\n    try {\n        credential = (await navigator.credentials.create(createOptions));\n    }\n    catch (err) {\n        throw identifyRegistrationError({ error: err, options: createOptions });\n    }\n    if (!credential) {\n        throw new Error('Registration was not completed');\n    }\n    const { id, rawId, response, type } = credential;\n    // Continue to play it safe with `getTransports()` for now, even when L3 types say it's required\n    let transports = undefined;\n    if (typeof response.getTransports === 'function') {\n        transports = response.getTransports();\n    }\n    // L3 says this is required, but browser and webview support are still not guaranteed.\n    let responsePublicKeyAlgorithm = undefined;\n    if (typeof response.getPublicKeyAlgorithm === 'function') {\n        try {\n            responsePublicKeyAlgorithm = response.getPublicKeyAlgorithm();\n        }\n        catch (error) {\n            warnOnBrokenImplementation('getPublicKeyAlgorithm()', error);\n        }\n    }\n    let responsePublicKey = undefined;\n    if (typeof response.getPublicKey === 'function') {\n        try {\n            const _publicKey = response.getPublicKey();\n            if (_publicKey !== null) {\n                responsePublicKey = bufferToBase64URLString(_publicKey);\n            }\n        }\n        catch (error) {\n            warnOnBrokenImplementation('getPublicKey()', error);\n        }\n    }\n    // L3 says this is required, but browser and webview support are still not guaranteed.\n    let responseAuthenticatorData;\n    if (typeof response.getAuthenticatorData === 'function') {\n        try {\n            responseAuthenticatorData = bufferToBase64URLString(response.getAuthenticatorData());\n        }\n        catch (error) {\n            warnOnBrokenImplementation('getAuthenticatorData()', error);\n        }\n    }\n    return {\n        id,\n        rawId: bufferToBase64URLString(rawId),\n        response: {\n            attestationObject: bufferToBase64URLString(response.attestationObject),\n            clientDataJSON: bufferToBase64URLString(response.clientDataJSON),\n            transports,\n            publicKeyAlgorithm: responsePublicKeyAlgorithm,\n            publicKey: responsePublicKey,\n            authenticatorData: responseAuthenticatorData,\n        },\n        type,\n        clientExtensionResults: credential.getClientExtensionResults(),\n        authenticatorAttachment: toAuthenticatorAttachment(credential.authenticatorAttachment),\n    };\n}\n/**\n * Visibly warn when we detect an issue related to a passkey provider intercepting WebAuthn API\n * calls\n */\nfunction warnOnBrokenImplementation(methodName, cause) {\n    console.warn(`The browser extension that intercepted this WebAuthn API call incorrectly implemented ${methodName}. You should report this error to them.\\n`, cause);\n}\n", "import { browserSupportsWebAuthn } from './browserSupportsWebAuthn.js';\n/**\n * Determine if the browser supports conditional UI, so that WebAuthn credentials can\n * be shown to the user in the browser's typical password autofill popup.\n */\nexport function browserSupportsWebAuthnAutofill() {\n    if (!browserSupportsWebAuthn()) {\n        return _browserSupportsWebAuthnAutofillInternals.stubThis(new Promise((resolve) => resolve(false)));\n    }\n    /**\n     * I don't like the `as unknown` here but there's a `declare var PublicKeyCredential` in\n     * TS' DOM lib that's making it difficult for me to just go `as PublicKeyCredentialFuture` as I\n     * want. I think I'm fine with this for now since it's _supposed_ to be temporary, until TS types\n     * have a chance to catch up.\n     */\n    const globalPublicKeyCredential = globalThis\n        .PublicKeyCredential;\n    if (globalPublicKeyCredential?.isConditionalMediationAvailable === undefined) {\n        return _browserSupportsWebAuthnAutofillInternals.stubThis(new Promise((resolve) => resolve(false)));\n    }\n    return _browserSupportsWebAuthnAutofillInternals.stubThis(globalPublicKeyCredential.isConditionalMediationAvailable());\n}\n// Make it possible to stub the return value during testing\nexport const _browserSupportsWebAuthnAutofillInternals = {\n    stubThis: (value) => value,\n};\n", "import { isValidDomain } from './isValidDomain.js';\nimport { WebAuthnError } from './webAuthnError.js';\n/**\n * Attempt to intuit _why_ an error was raised after calling `navigator.credentials.get()`\n */\nexport function identifyAuthenticationError({ error, options, }) {\n    const { publicKey } = options;\n    if (!publicKey) {\n        throw Error('options was missing required publicKey property');\n    }\n    if (error.name === 'AbortError') {\n        if (options.signal instanceof AbortSignal) {\n            // https://www.w3.org/TR/webauthn-2/#sctn-createCredential (Step 16)\n            return new WebAuthnError({\n                message: 'Authentication ceremony was sent an abort signal',\n                code: 'ERROR_CEREMONY_ABORTED',\n                cause: error,\n            });\n        }\n    }\n    else if (error.name === 'NotAllowedError') {\n        /**\n         * Pass the error directly through. Platforms are overloading this error beyond what the spec\n         * defines and we don't want to overwrite potentially useful error messages.\n         */\n        return new WebAuthnError({\n            message: error.message,\n            code: 'ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY',\n            cause: error,\n        });\n    }\n    else if (error.name === 'SecurityError') {\n        const effectiveDomain = globalThis.location.hostname;\n        if (!isValidDomain(effectiveDomain)) {\n            // https://www.w3.org/TR/webauthn-2/#sctn-discover-from-external-source (Step 5)\n            return new WebAuthnError({\n                message: `${globalThis.location.hostname} is an invalid domain`,\n                code: 'ERROR_INVALID_DOMAIN',\n                cause: error,\n            });\n        }\n        else if (publicKey.rpId !== effectiveDomain) {\n            // https://www.w3.org/TR/webauthn-2/#sctn-discover-from-external-source (Step 6)\n            return new WebAuthnError({\n                message: `The RP ID \"${publicKey.rpId}\" is invalid for this domain`,\n                code: 'ERROR_INVALID_RP_ID',\n                cause: error,\n            });\n        }\n    }\n    else if (error.name === 'UnknownError') {\n        // https://www.w3.org/TR/webauthn-2/#sctn-op-get-assertion (Step 1)\n        // https://www.w3.org/TR/webauthn-2/#sctn-op-get-assertion (Step 12)\n        return new WebAuthnError({\n            message: 'The authenticator was unable to process the specified options, or could not create a new assertion signature',\n            code: 'ERROR_AUTHENTICATOR_GENERAL_ERROR',\n            cause: error,\n        });\n    }\n    return error;\n}\n", "import { bufferToBase64URLString } from '../helpers/bufferToBase64URLString.js';\nimport { base64URLStringToBuffer } from '../helpers/base64URLStringToBuffer.js';\nimport { browserSupportsWebAuthn } from '../helpers/browserSupportsWebAuthn.js';\nimport { browserSupportsWebAuthnAutofill } from '../helpers/browserSupportsWebAuthnAutofill.js';\nimport { toPublicKeyCredentialDescriptor } from '../helpers/toPublicKeyCredentialDescriptor.js';\nimport { identifyAuthenticationError } from '../helpers/identifyAuthenticationError.js';\nimport { WebAuthnAbortService } from '../helpers/webAuthnAbortService.js';\nimport { toAuthenticatorAttachment } from '../helpers/toAuthenticatorAttachment.js';\n/**\n * Begin authenticator \"login\" via WebAuthn assertion\n *\n * @param optionsJSON Output from **@simplewebauthn/server**'s `generateAuthenticationOptions()`\n * @param useBrowserAutofill (Optional) Initialize conditional UI to enable logging in via browser autofill prompts. Defaults to `false`.\n * @param verifyBrowserAutofillInput (Optional) Ensure a suitable `<input>` element is present when `useBrowserAutofill` is `true`. Defaults to `true`.\n */\nexport async function startAuthentication(options) {\n    // @ts-ignore: Intentionally check for old call structure to warn about improper API call\n    if (!options.optionsJSON && options.challenge) {\n        console.warn('startAuthentication() was not called correctly. It will try to continue with the provided options, but this call should be refactored to use the expected call structure instead. See https://simplewebauthn.dev/docs/packages/browser#typeerror-cannot-read-properties-of-undefined-reading-challenge for more information.');\n        // @ts-ignore: Reassign the options, passed in as a positional argument, to the expected variable\n        options = { optionsJSON: options };\n    }\n    const { optionsJSON, useBrowserAutofill = false, verifyBrowserAutofillInput = true, } = options;\n    if (!browserSupportsWebAuthn()) {\n        throw new Error('WebAuthn is not supported in this browser');\n    }\n    // We need to avoid passing empty array to avoid blocking retrieval\n    // of public key\n    let allowCredentials;\n    if (optionsJSON.allowCredentials?.length !== 0) {\n        allowCredentials = optionsJSON.allowCredentials?.map(toPublicKeyCredentialDescriptor);\n    }\n    // We need to convert some values to Uint8Arrays before passing the credentials to the navigator\n    const publicKey = {\n        ...optionsJSON,\n        challenge: base64URLStringToBuffer(optionsJSON.challenge),\n        allowCredentials,\n    };\n    // Prepare options for `.get()`\n    const getOptions = {};\n    /**\n     * Set up the page to prompt the user to select a credential for authentication via the browser's\n     * input autofill mechanism.\n     */\n    if (useBrowserAutofill) {\n        if (!(await browserSupportsWebAuthnAutofill())) {\n            throw Error('Browser does not support WebAuthn autofill');\n        }\n        // Check for an <input> with \"webauthn\" in its `autocomplete` attribute\n        const eligibleInputs = document.querySelectorAll(\"input[autocomplete$='webauthn']\");\n        // WebAuthn autofill requires at least one valid input\n        if (eligibleInputs.length < 1 && verifyBrowserAutofillInput) {\n            throw Error('No <input> with \"webauthn\" as the only or last value in its `autocomplete` attribute was detected');\n        }\n        // `CredentialMediationRequirement` doesn't know about \"conditional\" yet as of\n        // typescript@4.6.3\n        getOptions.mediation = 'conditional';\n        // Conditional UI requires an empty allow list\n        publicKey.allowCredentials = [];\n    }\n    // Finalize options\n    getOptions.publicKey = publicKey;\n    // Set up the ability to cancel this request if the user attempts another\n    getOptions.signal = WebAuthnAbortService.createNewAbortSignal();\n    // Wait for the user to complete assertion\n    let credential;\n    try {\n        credential = (await navigator.credentials.get(getOptions));\n    }\n    catch (err) {\n        throw identifyAuthenticationError({ error: err, options: getOptions });\n    }\n    if (!credential) {\n        throw new Error('Authentication was not completed');\n    }\n    const { id, rawId, response, type } = credential;\n    let userHandle = undefined;\n    if (response.userHandle) {\n        userHandle = bufferToBase64URLString(response.userHandle);\n    }\n    // Convert values to base64 to make it easier to send back to the server\n    return {\n        id,\n        rawId: bufferToBase64URLString(rawId),\n        response: {\n            authenticatorData: bufferToBase64URLString(response.authenticatorData),\n            clientDataJSON: bufferToBase64URLString(response.clientDataJSON),\n            signature: bufferToBase64URLString(response.signature),\n            userHandle,\n        },\n        type,\n        clientExtensionResults: credential.getClientExtensionResults(),\n        authenticatorAttachment: toAuthenticatorAttachment(credential.authenticatorAttachment),\n    };\n}\n", "import type {\n\tBetterAuthClientPlugin,\n\tClientFetchOption,\n\tClientStore,\n} from \"@better-auth/core\";\nimport type { BetterFetch } from \"@better-fetch/fetch\";\nimport type {\n\tPublicKeyCredentialCreationOptionsJSON,\n\tPublicKeyCredentialRequestOptionsJSON,\n} from \"@simplewebauthn/browser\";\nimport {\n\tstartAuthentication,\n\tstartRegistration,\n\tWebAuthnError,\n} from \"@simplewebauthn/browser\";\nimport { useAuthQuery } from \"better-auth/client\";\nimport type { Session, User } from \"better-auth/types\";\nimport { atom } from \"nanostores\";\nimport type { passkey } from \".\";\nimport type { Passkey } from \"./types\";\n\nexport const getPasskeyActions = (\n\t$fetch: BetterFetch,\n\t{\n\t\t$listPasskeys,\n\t\t$store,\n\t}: {\n\t\t$listPasskeys: ReturnType<typeof atom<any>>;\n\t\t$store: ClientStore;\n\t},\n) => {\n\tconst signInPasskey = async (\n\t\topts?:\n\t\t\t| {\n\t\t\t\t\tautoFill?: boolean;\n\t\t\t\t\tfetchOptions?: ClientFetchOption;\n\t\t\t  }\n\t\t\t| undefined,\n\t\toptions?: ClientFetchOption | undefined,\n\t) => {\n\t\tconst response = await $fetch<PublicKeyCredentialRequestOptionsJSON>(\n\t\t\t\"/passkey/generate-authenticate-options\",\n\t\t\t{\n\t\t\t\tmethod: \"GET\",\n\t\t\t\tthrow: false,\n\t\t\t},\n\t\t);\n\t\tif (!response.data) {\n\t\t\treturn response;\n\t\t}\n\t\ttry {\n\t\t\tconst res = await startAuthentication({\n\t\t\t\toptionsJSON: response.data,\n\t\t\t\tuseBrowserAutofill: opts?.autoFill,\n\t\t\t});\n\t\t\tconst verified = await $fetch<{\n\t\t\t\tsession: Session;\n\t\t\t\tuser: User;\n\t\t\t}>(\"/passkey/verify-authentication\", {\n\t\t\t\tbody: {\n\t\t\t\t\tresponse: res,\n\t\t\t\t},\n\t\t\t\t...opts?.fetchOptions,\n\t\t\t\t...options,\n\t\t\t\tmethod: \"POST\",\n\t\t\t\tthrow: false,\n\t\t\t});\n\t\t\t$listPasskeys.set(Math.random());\n\t\t\t$store.notify(\"$sessionSignal\");\n\n\t\t\treturn verified;\n\t\t} catch (err) {\n\t\t\t// Error logs ran on the front-end\n\t\t\tconsole.error(`[Better Auth] Error verifying passkey`, err);\n\t\t\treturn {\n\t\t\t\tdata: null,\n\t\t\t\terror: {\n\t\t\t\t\tcode: \"AUTH_CANCELLED\",\n\t\t\t\t\tmessage: \"auth cancelled\",\n\t\t\t\t\tstatus: 400,\n\t\t\t\t\tstatusText: \"BAD_REQUEST\",\n\t\t\t\t},\n\t\t\t};\n\t\t}\n\t};\n\n\tconst registerPasskey = async (\n\t\topts?:\n\t\t\t| {\n\t\t\t\t\tfetchOptions?: ClientFetchOption;\n\t\t\t\t\t/**\n\t\t\t\t\t * The name of the passkey. This is used to\n\t\t\t\t\t * identify the passkey in the UI.\n\t\t\t\t\t */\n\t\t\t\t\tname?: string;\n\n\t\t\t\t\t/**\n\t\t\t\t\t * The type of attachment for the passkey. Defaults to both\n\t\t\t\t\t * platform and cross-platform allowed, with platform preferred.\n\t\t\t\t\t */\n\t\t\t\t\tauthenticatorAttachment?: \"platform\" | \"cross-platform\";\n\n\t\t\t\t\t/**\n\t\t\t\t\t * Try to silently create a passkey with the password manager that the user just signed\n\t\t\t\t\t * in with.\n\t\t\t\t\t * @default false\n\t\t\t\t\t */\n\t\t\t\t\tuseAutoRegister?: boolean;\n\t\t\t  }\n\t\t\t| undefined,\n\t\tfetchOpts?: ClientFetchOption | undefined,\n\t) => {\n\t\tconst options = await $fetch<PublicKeyCredentialCreationOptionsJSON>(\n\t\t\t\"/passkey/generate-register-options\",\n\t\t\t{\n\t\t\t\tmethod: \"GET\",\n\t\t\t\tquery: {\n\t\t\t\t\t...(opts?.authenticatorAttachment && {\n\t\t\t\t\t\tauthenticatorAttachment: opts.authenticatorAttachment,\n\t\t\t\t\t}),\n\t\t\t\t\t...(opts?.name && {\n\t\t\t\t\t\tname: opts.name,\n\t\t\t\t\t}),\n\t\t\t\t},\n\t\t\t\tthrow: false,\n\t\t\t},\n\t\t);\n\n\t\tif (!options.data) {\n\t\t\treturn options;\n\t\t}\n\t\ttry {\n\t\t\tconst res = await startRegistration({\n\t\t\t\toptionsJSON: options.data,\n\t\t\t\tuseAutoRegister: opts?.useAutoRegister,\n\t\t\t});\n\t\t\tconst verified = await $fetch<Passkey>(\"/passkey/verify-registration\", {\n\t\t\t\t...opts?.fetchOptions,\n\t\t\t\t...fetchOpts,\n\t\t\t\tbody: {\n\t\t\t\t\tresponse: res,\n\t\t\t\t\tname: opts?.name,\n\t\t\t\t},\n\t\t\t\tmethod: \"POST\",\n\t\t\t\tthrow: false,\n\t\t\t});\n\n\t\t\tif (!verified.data) {\n\t\t\t\treturn verified;\n\t\t\t}\n\t\t\t$listPasskeys.set(Math.random());\n\t\t\treturn verified;\n\t\t} catch (e) {\n\t\t\tif (e instanceof WebAuthnError) {\n\t\t\t\tif (e.code === \"ERROR_AUTHENTICATOR_PREVIOUSLY_REGISTERED\") {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tdata: null,\n\t\t\t\t\t\terror: {\n\t\t\t\t\t\t\tcode: e.code,\n\t\t\t\t\t\t\tmessage: \"previously registered\",\n\t\t\t\t\t\t\tstatus: 400,\n\t\t\t\t\t\t\tstatusText: \"BAD_REQUEST\",\n\t\t\t\t\t\t},\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tif (e.code === \"ERROR_CEREMONY_ABORTED\") {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tdata: null,\n\t\t\t\t\t\terror: {\n\t\t\t\t\t\t\tcode: e.code,\n\t\t\t\t\t\t\tmessage: \"registration cancelled\",\n\t\t\t\t\t\t\tstatus: 400,\n\t\t\t\t\t\t\tstatusText: \"BAD_REQUEST\",\n\t\t\t\t\t\t},\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\treturn {\n\t\t\t\t\tdata: null,\n\t\t\t\t\terror: {\n\t\t\t\t\t\tcode: e.code,\n\t\t\t\t\t\tmessage: e.message,\n\t\t\t\t\t\tstatus: 400,\n\t\t\t\t\t\tstatusText: \"BAD_REQUEST\",\n\t\t\t\t\t},\n\t\t\t\t};\n\t\t\t}\n\t\t\treturn {\n\t\t\t\tdata: null,\n\t\t\t\terror: {\n\t\t\t\t\tcode: \"UNKNOWN_ERROR\",\n\t\t\t\t\tmessage: e instanceof Error ? e.message : \"unknown error\",\n\t\t\t\t\tstatus: 500,\n\t\t\t\t\tstatusText: \"INTERNAL_SERVER_ERROR\",\n\t\t\t\t},\n\t\t\t};\n\t\t}\n\t};\n\n\treturn {\n\t\tsignIn: {\n\t\t\t/**\n\t\t\t * Sign in with a registered passkey\n\t\t\t */\n\t\t\tpasskey: signInPasskey,\n\t\t},\n\t\tpasskey: {\n\t\t\t/**\n\t\t\t * Add a passkey to the user account\n\t\t\t */\n\t\t\taddPasskey: registerPasskey,\n\t\t},\n\t\t/**\n\t\t * Inferred Internal Types\n\t\t */\n\t\t$Infer: {} as {\n\t\t\tPasskey: Passkey;\n\t\t},\n\t};\n};\n\nexport const passkeyClient = () => {\n\tconst $listPasskeys = atom<any>();\n\treturn {\n\t\tid: \"passkey\",\n\t\t$InferServerPlugin: {} as ReturnType<typeof passkey>,\n\t\tgetActions: ($fetch, $store) =>\n\t\t\tgetPasskeyActions($fetch, {\n\t\t\t\t$listPasskeys,\n\t\t\t\t$store,\n\t\t\t}),\n\t\tgetAtoms($fetch) {\n\t\t\tconst listPasskeys = useAuthQuery<Passkey[]>(\n\t\t\t\t$listPasskeys,\n\t\t\t\t\"/passkey/list-user-passkeys\",\n\t\t\t\t$fetch,\n\t\t\t\t{\n\t\t\t\t\tmethod: \"GET\",\n\t\t\t\t},\n\t\t\t);\n\t\t\treturn {\n\t\t\t\tlistPasskeys,\n\t\t\t\t$listPasskeys,\n\t\t\t};\n\t\t},\n\t\tpathMethods: {\n\t\t\t\"/passkey/register\": \"POST\",\n\t\t\t\"/passkey/authenticate\": \"POST\",\n\t\t},\n\t\tatomListeners: [\n\t\t\t{\n\t\t\t\tmatcher(path) {\n\t\t\t\t\treturn (\n\t\t\t\t\t\tpath === \"/passkey/verify-registration\" ||\n\t\t\t\t\t\tpath === \"/passkey/delete-passkey\" ||\n\t\t\t\t\t\tpath === \"/passkey/update-passkey\" ||\n\t\t\t\t\t\tpath === \"/sign-out\"\n\t\t\t\t\t);\n\t\t\t\t},\n\t\t\t\tsignal: \"$listPasskeys\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tmatcher: (path) => path === \"/passkey/verify-authentication\",\n\t\t\t\tsignal: \"$sessionSignal\",\n\t\t\t},\n\t\t],\n\t} satisfies BetterAuthClientPlugin;\n};\n\nexport type * from \"@simplewebauthn/server\";\nexport type * from \"./types\";\n"],
  "mappings": ";;;;;;;;;AAMO,SAAS,wBAAwB,QAAQ;AAC5C,QAAM,QAAQ,IAAI,WAAW,MAAM;AACnC,MAAI,MAAM;AACV,aAAW,YAAY,OAAO;AAC1B,WAAO,OAAO,aAAa,QAAQ;AAAA,EACvC;AACA,QAAM,eAAe,KAAK,GAAG;AAC7B,SAAO,aAAa,QAAQ,OAAO,GAAG,EAAE,QAAQ,OAAO,GAAG,EAAE,QAAQ,MAAM,EAAE;AAChF;;;ACPO,SAAS,wBAAwB,iBAAiB;AAErD,QAAM,SAAS,gBAAgB,QAAQ,MAAM,GAAG,EAAE,QAAQ,MAAM,GAAG;AAQnE,QAAM,aAAa,IAAK,OAAO,SAAS,KAAM;AAC9C,QAAM,SAAS,OAAO,OAAO,OAAO,SAAS,WAAW,GAAG;AAE3D,QAAM,SAAS,KAAK,MAAM;AAE1B,QAAM,SAAS,IAAI,YAAY,OAAO,MAAM;AAC5C,QAAM,QAAQ,IAAI,WAAW,MAAM;AACnC,WAAS,IAAI,GAAG,IAAI,OAAO,QAAQ,KAAK;AACpC,UAAM,CAAC,IAAI,OAAO,WAAW,CAAC;AAAA,EAClC;AACA,SAAO;AACX;;;ACzBO,SAAS,0BAA0B;AACtC,SAAO,kCAAkC,SAAS,YAAY,wBAAwB,UAClF,OAAO,WAAW,wBAAwB,UAAU;AAC5D;AAKO,IAAM,oCAAoC;AAAA,EAC7C,UAAU,CAAC,UAAU;AACzB;;;ACZO,SAAS,gCAAgC,YAAY;AACxD,QAAM,EAAE,GAAG,IAAI;AACf,SAAO;AAAA,IACH,GAAG;AAAA,IACH,IAAI,wBAAwB,EAAE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAM9B,YAAY,WAAW;AAAA,EAC3B;AACJ;;;ACLO,SAAS,cAAc,UAAU;AACpC;AAAA;AAAA,IAEA,aAAa,eACT,0CAA0C,KAAK,QAAQ;AAAA;AAC/D;;;ACIO,IAAM,gBAAN,cAA4B,MAAM;AAAA,EACrC,YAAY,EAAE,SAAS,MAAM,OAAO,KAAM,GAAG;AAEzC,UAAM,SAAS,EAAE,MAAM,CAAC;AACxB,WAAO,eAAe,MAAM,QAAQ;AAAA,MAChC,YAAY;AAAA,MACZ,cAAc;AAAA,MACd,UAAU;AAAA,MACV,OAAO;AAAA,IACX,CAAC;AACD,SAAK,OAAO,QAAQ,MAAM;AAC1B,SAAK,OAAO;AAAA,EAChB;AACJ;;;ACzBO,SAAS,0BAA0B,EAAE,OAAO,QAAS,GAAG;AAC3D,QAAM,EAAE,UAAU,IAAI;AACtB,MAAI,CAAC,WAAW;AACZ,UAAM,MAAM,iDAAiD;AAAA,EACjE;AACA,MAAI,MAAM,SAAS,cAAc;AAC7B,QAAI,QAAQ,kBAAkB,aAAa;AAEvC,aAAO,IAAI,cAAc;AAAA,QACrB,SAAS;AAAA,QACT,MAAM;AAAA,QACN,OAAO;AAAA,MACX,CAAC;AAAA,IACL;AAAA,EACJ,WACS,MAAM,SAAS,mBAAmB;AACvC,QAAI,UAAU,wBAAwB,uBAAuB,MAAM;AAE/D,aAAO,IAAI,cAAc;AAAA,QACrB,SAAS;AAAA,QACT,MAAM;AAAA,QACN,OAAO;AAAA,MACX,CAAC;AAAA,IACL;AAAA;AAAA,MAGA,QAAQ,cAAc,iBAClB,UAAU,wBAAwB,qBAAqB;AAAA,MAAY;AAEnE,aAAO,IAAI,cAAc;AAAA,QACrB,SAAS;AAAA,QACT,MAAM;AAAA,QACN,OAAO;AAAA,MACX,CAAC;AAAA,IACL,WACS,UAAU,wBAAwB,qBAAqB,YAAY;AAExE,aAAO,IAAI,cAAc;AAAA,QACrB,SAAS;AAAA,QACT,MAAM;AAAA,QACN,OAAO;AAAA,MACX,CAAC;AAAA,IACL;AAAA,EACJ,WACS,MAAM,SAAS,qBAAqB;AAGzC,WAAO,IAAI,cAAc;AAAA,MACrB,SAAS;AAAA,MACT,MAAM;AAAA,MACN,OAAO;AAAA,IACX,CAAC;AAAA,EACL,WACS,MAAM,SAAS,mBAAmB;AAKvC,WAAO,IAAI,cAAc;AAAA,MACrB,SAAS,MAAM;AAAA,MACf,MAAM;AAAA,MACN,OAAO;AAAA,IACX,CAAC;AAAA,EACL,WACS,MAAM,SAAS,qBAAqB;AACzC,UAAM,wBAAwB,UAAU,iBAAiB,OAAO,CAAC,UAAU,MAAM,SAAS,YAAY;AACtG,QAAI,sBAAsB,WAAW,GAAG;AAEpC,aAAO,IAAI,cAAc;AAAA,QACrB,SAAS;AAAA,QACT,MAAM;AAAA,QACN,OAAO;AAAA,MACX,CAAC;AAAA,IACL;AAEA,WAAO,IAAI,cAAc;AAAA,MACrB,SAAS;AAAA,MACT,MAAM;AAAA,MACN,OAAO;AAAA,IACX,CAAC;AAAA,EACL,WACS,MAAM,SAAS,iBAAiB;AACrC,UAAM,kBAAkB,WAAW,SAAS;AAC5C,QAAI,CAAC,cAAc,eAAe,GAAG;AAEjC,aAAO,IAAI,cAAc;AAAA,QACrB,SAAS,GAAG,WAAW,SAAS,QAAQ;AAAA,QACxC,MAAM;AAAA,QACN,OAAO;AAAA,MACX,CAAC;AAAA,IACL,WACS,UAAU,GAAG,OAAO,iBAAiB;AAE1C,aAAO,IAAI,cAAc;AAAA,QACrB,SAAS,cAAc,UAAU,GAAG,EAAE;AAAA,QACtC,MAAM;AAAA,QACN,OAAO;AAAA,MACX,CAAC;AAAA,IACL;AAAA,EACJ,WACS,MAAM,SAAS,aAAa;AACjC,QAAI,UAAU,KAAK,GAAG,aAAa,KAAK,UAAU,KAAK,GAAG,aAAa,IAAI;AAEvE,aAAO,IAAI,cAAc;AAAA,QACrB,SAAS;AAAA,QACT,MAAM;AAAA,QACN,OAAO;AAAA,MACX,CAAC;AAAA,IACL;AAAA,EACJ,WACS,MAAM,SAAS,gBAAgB;AAGpC,WAAO,IAAI,cAAc;AAAA,MACrB,SAAS;AAAA,MACT,MAAM;AAAA,MACN,OAAO;AAAA,IACX,CAAC;AAAA,EACL;AACA,SAAO;AACX;;;AC7HA,IAAM,2BAAN,MAA+B;AAAA,EAC3B,cAAc;AACV,WAAO,eAAe,MAAM,cAAc;AAAA,MACtC,YAAY;AAAA,MACZ,cAAc;AAAA,MACd,UAAU;AAAA,MACV,OAAO;AAAA,IACX,CAAC;AAAA,EACL;AAAA,EACA,uBAAuB;AAEnB,QAAI,KAAK,YAAY;AACjB,YAAM,aAAa,IAAI,MAAM,mDAAmD;AAChF,iBAAW,OAAO;AAClB,WAAK,WAAW,MAAM,UAAU;AAAA,IACpC;AACA,UAAM,gBAAgB,IAAI,gBAAgB;AAC1C,SAAK,aAAa;AAClB,WAAO,cAAc;AAAA,EACzB;AAAA,EACA,iBAAiB;AACb,QAAI,KAAK,YAAY;AACjB,YAAM,aAAa,IAAI,MAAM,gDAAgD;AAC7E,iBAAW,OAAO;AAClB,WAAK,WAAW,MAAM,UAAU;AAChC,WAAK,aAAa;AAAA,IACtB;AAAA,EACJ;AACJ;AAQO,IAAM,uBAAuB,IAAI,yBAAyB;;;ACpCjE,IAAM,cAAc,CAAC,kBAAkB,UAAU;AAI1C,SAAS,0BAA0B,YAAY;AAClD,MAAI,CAAC,YAAY;AACb;AAAA,EACJ;AACA,MAAI,YAAY,QAAQ,UAAU,IAAI,GAAG;AACrC;AAAA,EACJ;AACA,SAAO;AACX;;;ACCA,eAAsB,kBAAkB,SAAS;AAE7C,MAAI,CAAC,QAAQ,eAAe,QAAQ,WAAW;AAC3C,YAAQ,KAAK,4TAA4T;AAEzU,cAAU,EAAE,aAAa,QAAQ;AAAA,EACrC;AACA,QAAM,EAAE,aAAa,kBAAkB,MAAM,IAAI;AACjD,MAAI,CAAC,wBAAwB,GAAG;AAC5B,UAAM,IAAI,MAAM,2CAA2C;AAAA,EAC/D;AAEA,QAAM,YAAY;AAAA,IACd,GAAG;AAAA,IACH,WAAW,wBAAwB,YAAY,SAAS;AAAA,IACxD,MAAM;AAAA,MACF,GAAG,YAAY;AAAA,MACf,IAAI,wBAAwB,YAAY,KAAK,EAAE;AAAA,IACnD;AAAA,IACA,oBAAoB,YAAY,oBAAoB,IAAI,+BAA+B;AAAA,EAC3F;AAEA,QAAM,gBAAgB,CAAC;AAMvB,MAAI,iBAAiB;AAEjB,kBAAc,YAAY;AAAA,EAC9B;AAEA,gBAAc,YAAY;AAE1B,gBAAc,SAAS,qBAAqB,qBAAqB;AAEjE,MAAI;AACJ,MAAI;AACA,iBAAc,MAAM,UAAU,YAAY,OAAO,aAAa;AAAA,EAClE,SACO,KAAK;AACR,UAAM,0BAA0B,EAAE,OAAO,KAAK,SAAS,cAAc,CAAC;AAAA,EAC1E;AACA,MAAI,CAAC,YAAY;AACb,UAAM,IAAI,MAAM,gCAAgC;AAAA,EACpD;AACA,QAAM,EAAE,IAAI,OAAO,UAAU,KAAK,IAAI;AAEtC,MAAI,aAAa;AACjB,MAAI,OAAO,SAAS,kBAAkB,YAAY;AAC9C,iBAAa,SAAS,cAAc;AAAA,EACxC;AAEA,MAAI,6BAA6B;AACjC,MAAI,OAAO,SAAS,0BAA0B,YAAY;AACtD,QAAI;AACA,mCAA6B,SAAS,sBAAsB;AAAA,IAChE,SACO,OAAO;AACV,iCAA2B,2BAA2B,KAAK;AAAA,IAC/D;AAAA,EACJ;AACA,MAAI,oBAAoB;AACxB,MAAI,OAAO,SAAS,iBAAiB,YAAY;AAC7C,QAAI;AACA,YAAM,aAAa,SAAS,aAAa;AACzC,UAAI,eAAe,MAAM;AACrB,4BAAoB,wBAAwB,UAAU;AAAA,MAC1D;AAAA,IACJ,SACO,OAAO;AACV,iCAA2B,kBAAkB,KAAK;AAAA,IACtD;AAAA,EACJ;AAEA,MAAI;AACJ,MAAI,OAAO,SAAS,yBAAyB,YAAY;AACrD,QAAI;AACA,kCAA4B,wBAAwB,SAAS,qBAAqB,CAAC;AAAA,IACvF,SACO,OAAO;AACV,iCAA2B,0BAA0B,KAAK;AAAA,IAC9D;AAAA,EACJ;AACA,SAAO;AAAA,IACH;AAAA,IACA,OAAO,wBAAwB,KAAK;AAAA,IACpC,UAAU;AAAA,MACN,mBAAmB,wBAAwB,SAAS,iBAAiB;AAAA,MACrE,gBAAgB,wBAAwB,SAAS,cAAc;AAAA,MAC/D;AAAA,MACA,oBAAoB;AAAA,MACpB,WAAW;AAAA,MACX,mBAAmB;AAAA,IACvB;AAAA,IACA;AAAA,IACA,wBAAwB,WAAW,0BAA0B;AAAA,IAC7D,yBAAyB,0BAA0B,WAAW,uBAAuB;AAAA,EACzF;AACJ;AAKA,SAAS,2BAA2B,YAAY,OAAO;AACnD,UAAQ,KAAK,yFAAyF,UAAU;AAAA,GAA6C,KAAK;AACtK;;;ACnHO,SAAS,kCAAkC;AAC9C,MAAI,CAAC,wBAAwB,GAAG;AAC5B,WAAO,0CAA0C,SAAS,IAAI,QAAQ,CAAC,YAAY,QAAQ,KAAK,CAAC,CAAC;AAAA,EACtG;AAOA,QAAM,4BAA4B,WAC7B;AACL,MAAI,2BAA2B,oCAAoC,QAAW;AAC1E,WAAO,0CAA0C,SAAS,IAAI,QAAQ,CAAC,YAAY,QAAQ,KAAK,CAAC,CAAC;AAAA,EACtG;AACA,SAAO,0CAA0C,SAAS,0BAA0B,gCAAgC,CAAC;AACzH;AAEO,IAAM,4CAA4C;AAAA,EACrD,UAAU,CAAC,UAAU;AACzB;;;ACpBO,SAAS,4BAA4B,EAAE,OAAO,QAAS,GAAG;AAC7D,QAAM,EAAE,UAAU,IAAI;AACtB,MAAI,CAAC,WAAW;AACZ,UAAM,MAAM,iDAAiD;AAAA,EACjE;AACA,MAAI,MAAM,SAAS,cAAc;AAC7B,QAAI,QAAQ,kBAAkB,aAAa;AAEvC,aAAO,IAAI,cAAc;AAAA,QACrB,SAAS;AAAA,QACT,MAAM;AAAA,QACN,OAAO;AAAA,MACX,CAAC;AAAA,IACL;AAAA,EACJ,WACS,MAAM,SAAS,mBAAmB;AAKvC,WAAO,IAAI,cAAc;AAAA,MACrB,SAAS,MAAM;AAAA,MACf,MAAM;AAAA,MACN,OAAO;AAAA,IACX,CAAC;AAAA,EACL,WACS,MAAM,SAAS,iBAAiB;AACrC,UAAM,kBAAkB,WAAW,SAAS;AAC5C,QAAI,CAAC,cAAc,eAAe,GAAG;AAEjC,aAAO,IAAI,cAAc;AAAA,QACrB,SAAS,GAAG,WAAW,SAAS,QAAQ;AAAA,QACxC,MAAM;AAAA,QACN,OAAO;AAAA,MACX,CAAC;AAAA,IACL,WACS,UAAU,SAAS,iBAAiB;AAEzC,aAAO,IAAI,cAAc;AAAA,QACrB,SAAS,cAAc,UAAU,IAAI;AAAA,QACrC,MAAM;AAAA,QACN,OAAO;AAAA,MACX,CAAC;AAAA,IACL;AAAA,EACJ,WACS,MAAM,SAAS,gBAAgB;AAGpC,WAAO,IAAI,cAAc;AAAA,MACrB,SAAS;AAAA,MACT,MAAM;AAAA,MACN,OAAO;AAAA,IACX,CAAC;AAAA,EACL;AACA,SAAO;AACX;;;AC7CA,eAAsB,oBAAoB,SAAS;AAE/C,MAAI,CAAC,QAAQ,eAAe,QAAQ,WAAW;AAC3C,YAAQ,KAAK,8TAA8T;AAE3U,cAAU,EAAE,aAAa,QAAQ;AAAA,EACrC;AACA,QAAM,EAAE,aAAa,qBAAqB,OAAO,6BAA6B,KAAM,IAAI;AACxF,MAAI,CAAC,wBAAwB,GAAG;AAC5B,UAAM,IAAI,MAAM,2CAA2C;AAAA,EAC/D;AAGA,MAAI;AACJ,MAAI,YAAY,kBAAkB,WAAW,GAAG;AAC5C,uBAAmB,YAAY,kBAAkB,IAAI,+BAA+B;AAAA,EACxF;AAEA,QAAM,YAAY;AAAA,IACd,GAAG;AAAA,IACH,WAAW,wBAAwB,YAAY,SAAS;AAAA,IACxD;AAAA,EACJ;AAEA,QAAM,aAAa,CAAC;AAKpB,MAAI,oBAAoB;AACpB,QAAI,CAAE,MAAM,gCAAgC,GAAI;AAC5C,YAAM,MAAM,4CAA4C;AAAA,IAC5D;AAEA,UAAM,iBAAiB,SAAS,iBAAiB,iCAAiC;AAElF,QAAI,eAAe,SAAS,KAAK,4BAA4B;AACzD,YAAM,MAAM,mGAAmG;AAAA,IACnH;AAGA,eAAW,YAAY;AAEvB,cAAU,mBAAmB,CAAC;AAAA,EAClC;AAEA,aAAW,YAAY;AAEvB,aAAW,SAAS,qBAAqB,qBAAqB;AAE9D,MAAI;AACJ,MAAI;AACA,iBAAc,MAAM,UAAU,YAAY,IAAI,UAAU;AAAA,EAC5D,SACO,KAAK;AACR,UAAM,4BAA4B,EAAE,OAAO,KAAK,SAAS,WAAW,CAAC;AAAA,EACzE;AACA,MAAI,CAAC,YAAY;AACb,UAAM,IAAI,MAAM,kCAAkC;AAAA,EACtD;AACA,QAAM,EAAE,IAAI,OAAO,UAAU,KAAK,IAAI;AACtC,MAAI,aAAa;AACjB,MAAI,SAAS,YAAY;AACrB,iBAAa,wBAAwB,SAAS,UAAU;AAAA,EAC5D;AAEA,SAAO;AAAA,IACH;AAAA,IACA,OAAO,wBAAwB,KAAK;AAAA,IACpC,UAAU;AAAA,MACN,mBAAmB,wBAAwB,SAAS,iBAAiB;AAAA,MACrE,gBAAgB,wBAAwB,SAAS,cAAc;AAAA,MAC/D,WAAW,wBAAwB,SAAS,SAAS;AAAA,MACrD;AAAA,IACJ;AAAA,IACA;AAAA,IACA,wBAAwB,WAAW,0BAA0B;AAAA,IAC7D,yBAAyB,0BAA0B,WAAW,uBAAuB;AAAA,EACzF;AACJ;;;ACzEA,IAAa,oBAAA,CACZ,QACA,EACC,eACA,OAAA,MAKG;AACJ,QAAM,gBAAgB,OACrB,MAMA,YACI;AACJ,UAAM,WAAW,MAAM,OACtB,0CACA;MACC,QAAQ;MACR,OAAO;KACP;AAEF,QAAI,CAAC,SAAS,KACb,QAAO;AAER,QAAI;AAKH,YAAM,WAAW,MAAM,OAGpB,kCAAkC;QACpC,MAAM,EACL,UATU,MAAM,oBAAoB;UACrC,aAAa,SAAS;UACtB,oBAAoB,MAAM;SAC1B,EAAC;QAQD,GAAG,MAAM;QACT,GAAG;QACH,QAAQ;QACR,OAAO;OACP;AACD,oBAAc,IAAI,KAAK,OAAA,CAAQ;AAC/B,aAAO,OAAO,gBAAA;AAEd,aAAO;aACC,KAAK;AAEb,cAAQ,MAAM,yCAAyC,GAAA;AACvD,aAAO;QACN,MAAM;QACN,OAAO;UACN,MAAM;UACN,SAAS;UACT,QAAQ;UACR,YAAY;;;;;AAMhB,QAAM,kBAAkB,OACvB,MAuBA,cACI;AACJ,UAAM,UAAU,MAAM,OACrB,sCACA;MACC,QAAQ;MACR,OAAO;QACN,GAAI,MAAM,2BAA2B,EACpC,yBAAyB,KAAK,wBAAA;QAE/B,GAAI,MAAM,QAAQ,EACjB,MAAM,KAAK,KAAA;;MAGb,OAAO;KACP;AAGF,QAAI,CAAC,QAAQ,KACZ,QAAO;AAER,QAAI;AACH,YAAM,MAAM,MAAM,kBAAkB;QACnC,aAAa,QAAQ;QACrB,iBAAiB,MAAM;OACvB;AACD,YAAM,WAAW,MAAM,OAAgB,gCAAgC;QACtE,GAAG,MAAM;QACT,GAAG;QACH,MAAM;UACL,UAAU;UACV,MAAM,MAAM;;QAEb,QAAQ;QACR,OAAO;OACP;AAED,UAAI,CAAC,SAAS,KACb,QAAO;AAER,oBAAc,IAAI,KAAK,OAAA,CAAQ;AAC/B,aAAO;aACC,GAAG;AACX,UAAI,aAAa,eAAe;AAC/B,YAAI,EAAE,SAAS,4CACd,QAAO;UACN,MAAM;UACN,OAAO;YACN,MAAM,EAAE;YACR,SAAS;YACT,QAAQ;YACR,YAAY;;;AAIf,YAAI,EAAE,SAAS,yBACd,QAAO;UACN,MAAM;UACN,OAAO;YACN,MAAM,EAAE;YACR,SAAS;YACT,QAAQ;YACR,YAAY;;;AAIf,eAAO;UACN,MAAM;UACN,OAAO;YACN,MAAM,EAAE;YACR,SAAS,EAAE;YACX,QAAQ;YACR,YAAY;;;;AAIf,aAAO;QACN,MAAM;QACN,OAAO;UACN,MAAM;UACN,SAAS,aAAa,QAAQ,EAAE,UAAU;UAC1C,QAAQ;UACR,YAAY;;;;;AAMhB,SAAO;IACN,QAAQ,EAIP,SAAS,cAAA;IAEV,SAAS,EAIR,YAAY,gBAAA;IAKb,QAAQ,CAAA;;;AAMV,IAAa,gBAAA,MAAsB;AAClC,QAAM,gBAAgB,KAAA;AACtB,SAAO;IACN,IAAI;IACJ,oBAAoB,CAAA;IACpB,YAAA,CAAa,QAAQ,WACpB,kBAAkB,QAAQ;MACzB;MACA;KACA;IACF,SAAS,QAAQ;AAShB,aAAO;QACN,cAToB,aACpB,eACA,+BACA,QACA,EACC,QAAQ,MAAA,CACR;QAID;;;IAGF,aAAa;MACZ,qBAAqB;MACrB,yBAAyB;;IAE1B,eAAe,CACd;MACC,QAAQ,MAAM;AACb,eACC,SAAS,kCACT,SAAS,6BACT,SAAS,6BACT,SAAS;;MAGX,QAAQ;OAET;MACC,SAAA,CAAU,SAAS,SAAS;MAC5B,QAAQ;KACR;;;",
  "names": []
}
